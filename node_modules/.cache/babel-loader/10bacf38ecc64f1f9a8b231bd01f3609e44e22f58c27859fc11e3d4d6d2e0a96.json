{"ast":null,"code":"// WebCrypto API를 사용한 암호화 유틸리티\n\n// IndexedDB 데이터베이스 이름 및 설정\nconst DB_NAME = 'CryptoKeysDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'privateKeys';\n\n/**\n * IndexedDB 데이터베이스 초기화\n * @returns {Promise<IDBDatabase>}\n */\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = () => {\n      reject(new Error('IndexedDB 초기화 실패'));\n    };\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME, {\n          keyPath: 'id'\n        });\n      }\n    };\n  });\n};\n\n/**\n * RSA 키 쌍 생성 (개인키와 공개키)\n * 개인키는 extractable: false로 생성되어 내보낼 수 없음\n * @returns {Promise<{privateKey: CryptoKey, publicKey: CryptoKey}>}\n */\nexport const generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: 'RSA-OAEP',\n      modulusLength: 2048,\n      // 2048비트 키\n      publicExponent: new Uint8Array([1, 0, 1]),\n      // 65537\n      hash: 'SHA-256'\n    }, false,\n    // extractable: false - 키를 내보낼 수 없음 (보안 강화)\n    ['encrypt', 'decrypt'] // 사용 용도\n    );\n    return {\n      privateKey: keyPair.privateKey,\n      publicKey: keyPair.publicKey\n    };\n  } catch (error) {\n    console.error('키 쌍 생성 실패:', error);\n    throw new Error('키 쌍 생성에 실패했습니다.');\n  }\n};\n\n/**\n * CryptoKey를 PEM 형식의 문자열로 변환\n * 주의: extractable: false인 키는 내보낼 수 없음\n * @param {CryptoKey} key - 변환할 키\n * @param {boolean} isPrivate - 개인키 여부\n * @returns {Promise<string>} PEM 형식의 키 문자열\n */\nexport const exportKeyToPEM = async (key, isPrivate = false) => {\n  try {\n    var _exportedAsBase64$mat;\n    const format = isPrivate ? 'pkcs8' : 'spki';\n    const exported = await window.crypto.subtle.exportKey(format, key);\n    const exportedAsBuffer = new Uint8Array(exported);\n    const exportedAsBase64 = btoa(String.fromCharCode(...exportedAsBuffer));\n    const header = isPrivate ? '-----BEGIN PRIVATE KEY-----\\n' : '-----BEGIN PUBLIC KEY-----\\n';\n    const footer = isPrivate ? '\\n-----END PRIVATE KEY-----' : '\\n-----END PUBLIC KEY-----';\n\n    // 64자마다 줄바꿈 추가\n    const base64WithLineBreaks = ((_exportedAsBase64$mat = exportedAsBase64.match(/.{1,64}/g)) === null || _exportedAsBase64$mat === void 0 ? void 0 : _exportedAsBase64$mat.join('\\n')) || exportedAsBase64;\n    return header + base64WithLineBreaks + footer;\n  } catch (error) {\n    console.error('키 변환 실패:', error);\n    throw new Error('키를 PEM 형식으로 변환하는데 실패했습니다.');\n  }\n};\n\n// 메모리 기반 키 저장소 (extractable: false인 CryptoKey는 IndexedDB에 저장 불가)\n// CryptoKey 객체는 구조화된 복제 알고리즘을 지원하지 않으므로 메모리에만 저장 가능\nlet privateKeyCache = null;\n\n/**\n * 개인키를 메모리에 안전하게 저장\n * extractable: false인 CryptoKey는 IndexedDB에 저장할 수 없으므로 메모리에 저장\n * @param {CryptoKey} privateKey - CryptoKey 객체 (extractable: false)\n * @returns {Promise<void>}\n */\nexport const savePrivateKey = async privateKey => {\n  try {\n    // extractable: false인 CryptoKey는 IndexedDB에 저장할 수 없음\n    // 구조화된 복제 알고리즘을 지원하지 않기 때문\n    // 따라서 메모리에만 저장 (페이지 새로고침 시 사라짐)\n    privateKeyCache = privateKey;\n\n    // IndexedDB에는 키 존재 여부만 저장 (메타데이터)\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    await new Promise((resolve, reject) => {\n      const request = store.put({\n        id: 'userPrivateKey',\n        exists: true,\n        createdAt: new Date().toISOString()\n      });\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 메타데이터 저장 실패'));\n    });\n    db.close();\n  } catch (error) {\n    console.error('개인키 저장 실패:', error);\n    throw new Error('개인키 저장에 실패했습니다.');\n  }\n};\n\n/**\n * IndexedDB에서 개인키 가져오기\n * @returns {Promise<CryptoKey|null>} CryptoKey 객체 또는 null\n */\nexport const getPrivateKey = async () => {\n  try {\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get('userPrivateKey');\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('개인키 읽기 실패'));\n    });\n    db.close();\n    return (result === null || result === void 0 ? void 0 : result.key) || null;\n  } catch (error) {\n    console.error('개인키 읽기 실패:', error);\n    return null;\n  }\n};\n\n/**\n * 개인키 삭제\n * @returns {Promise<void>}\n */\nexport const clearPrivateKey = async () => {\n  try {\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    await new Promise((resolve, reject) => {\n      const request = store.delete('userPrivateKey');\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 삭제 실패'));\n    });\n    db.close();\n  } catch (error) {\n    console.error('개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 키 쌍 생성 및 공개키를 PEM 형식으로 반환\n * 개인키는 extractable: false로 생성되어 IndexedDB에 저장됨\n * @returns {Promise<{publicKeyPEM: string}>}\n */\nexport const generateAndExportKeyPair = async () => {\n  try {\n    // 키 쌍 생성 (개인키는 extractable: false)\n    const {\n      privateKey,\n      publicKey\n    } = await generateKeyPair();\n\n    // 공개키만 PEM 형식으로 변환 (개인키는 extractable: false이므로 변환 불가)\n    const publicKeyPEM = await exportKeyToPEM(publicKey, false);\n\n    // 개인키는 IndexedDB에 저장 (CryptoKey 객체 자체)\n    await savePrivateKey(privateKey);\n    return {\n      publicKeyPEM\n    };\n  } catch (error) {\n    console.error('키 생성 및 변환 실패:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","STORE_NAME","initDB","Promise","resolve","reject","request","indexedDB","open","onerror","Error","onsuccess","result","onupgradeneeded","event","db","target","objectStoreNames","contains","createObjectStore","keyPath","generateKeyPair","keyPair","window","crypto","subtle","generateKey","name","modulusLength","publicExponent","Uint8Array","hash","privateKey","publicKey","error","console","exportKeyToPEM","key","isPrivate","_exportedAsBase64$mat","format","exported","exportKey","exportedAsBuffer","exportedAsBase64","btoa","String","fromCharCode","header","footer","base64WithLineBreaks","match","join","privateKeyCache","savePrivateKey","transaction","store","objectStore","put","id","exists","createdAt","Date","toISOString","close","getPrivateKey","get","clearPrivateKey","delete","generateAndExportKeyPair","publicKeyPEM"],"sources":["/Users/parkchanyu/Developer/FACT_Front/frontend/src/utils/crypto.js"],"sourcesContent":["// WebCrypto API를 사용한 암호화 유틸리티\n\n// IndexedDB 데이터베이스 이름 및 설정\nconst DB_NAME = 'CryptoKeysDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'privateKeys';\n\n/**\n * IndexedDB 데이터베이스 초기화\n * @returns {Promise<IDBDatabase>}\n */\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => {\n      reject(new Error('IndexedDB 초기화 실패'));\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n      }\n    };\n  });\n};\n\n/**\n * RSA 키 쌍 생성 (개인키와 공개키)\n * 개인키는 extractable: false로 생성되어 내보낼 수 없음\n * @returns {Promise<{privateKey: CryptoKey, publicKey: CryptoKey}>}\n */\nexport const generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey(\n      {\n        name: 'RSA-OAEP',\n        modulusLength: 2048, // 2048비트 키\n        publicExponent: new Uint8Array([1, 0, 1]), // 65537\n        hash: 'SHA-256',\n      },\n      false, // extractable: false - 키를 내보낼 수 없음 (보안 강화)\n      ['encrypt', 'decrypt'] // 사용 용도\n    );\n\n    return {\n      privateKey: keyPair.privateKey,\n      publicKey: keyPair.publicKey,\n    };\n  } catch (error) {\n    console.error('키 쌍 생성 실패:', error);\n    throw new Error('키 쌍 생성에 실패했습니다.');\n  }\n};\n\n/**\n * CryptoKey를 PEM 형식의 문자열로 변환\n * 주의: extractable: false인 키는 내보낼 수 없음\n * @param {CryptoKey} key - 변환할 키\n * @param {boolean} isPrivate - 개인키 여부\n * @returns {Promise<string>} PEM 형식의 키 문자열\n */\nexport const exportKeyToPEM = async (key, isPrivate = false) => {\n  try {\n    const format = isPrivate ? 'pkcs8' : 'spki';\n    const exported = await window.crypto.subtle.exportKey(format, key);\n    const exportedAsBuffer = new Uint8Array(exported);\n    const exportedAsBase64 = btoa(String.fromCharCode(...exportedAsBuffer));\n    const header = isPrivate\n      ? '-----BEGIN PRIVATE KEY-----\\n'\n      : '-----BEGIN PUBLIC KEY-----\\n';\n    const footer = isPrivate\n      ? '\\n-----END PRIVATE KEY-----'\n      : '\\n-----END PUBLIC KEY-----';\n    \n    // 64자마다 줄바꿈 추가\n    const base64WithLineBreaks = exportedAsBase64.match(/.{1,64}/g)?.join('\\n') || exportedAsBase64;\n    \n    return header + base64WithLineBreaks + footer;\n  } catch (error) {\n    console.error('키 변환 실패:', error);\n    throw new Error('키를 PEM 형식으로 변환하는데 실패했습니다.');\n  }\n};\n\n// 메모리 기반 키 저장소 (extractable: false인 CryptoKey는 IndexedDB에 저장 불가)\n// CryptoKey 객체는 구조화된 복제 알고리즘을 지원하지 않으므로 메모리에만 저장 가능\nlet privateKeyCache = null;\n\n/**\n * 개인키를 메모리에 안전하게 저장\n * extractable: false인 CryptoKey는 IndexedDB에 저장할 수 없으므로 메모리에 저장\n * @param {CryptoKey} privateKey - CryptoKey 객체 (extractable: false)\n * @returns {Promise<void>}\n */\nexport const savePrivateKey = async (privateKey) => {\n  try {\n    // extractable: false인 CryptoKey는 IndexedDB에 저장할 수 없음\n    // 구조화된 복제 알고리즘을 지원하지 않기 때문\n    // 따라서 메모리에만 저장 (페이지 새로고침 시 사라짐)\n    privateKeyCache = privateKey;\n    \n    // IndexedDB에는 키 존재 여부만 저장 (메타데이터)\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise((resolve, reject) => {\n      const request = store.put({\n        id: 'userPrivateKey',\n        exists: true,\n        createdAt: new Date().toISOString(),\n      });\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 메타데이터 저장 실패'));\n    });\n\n    db.close();\n  } catch (error) {\n    console.error('개인키 저장 실패:', error);\n    throw new Error('개인키 저장에 실패했습니다.');\n  }\n};\n\n/**\n * IndexedDB에서 개인키 가져오기\n * @returns {Promise<CryptoKey|null>} CryptoKey 객체 또는 null\n */\nexport const getPrivateKey = async () => {\n  try {\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get('userPrivateKey');\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('개인키 읽기 실패'));\n    });\n\n    db.close();\n\n    return result?.key || null;\n  } catch (error) {\n    console.error('개인키 읽기 실패:', error);\n    return null;\n  }\n};\n\n/**\n * 개인키 삭제\n * @returns {Promise<void>}\n */\nexport const clearPrivateKey = async () => {\n  try {\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise((resolve, reject) => {\n      const request = store.delete('userPrivateKey');\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 삭제 실패'));\n    });\n\n    db.close();\n  } catch (error) {\n    console.error('개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 키 쌍 생성 및 공개키를 PEM 형식으로 반환\n * 개인키는 extractable: false로 생성되어 IndexedDB에 저장됨\n * @returns {Promise<{publicKeyPEM: string}>}\n */\nexport const generateAndExportKeyPair = async () => {\n  try {\n    // 키 쌍 생성 (개인키는 extractable: false)\n    const { privateKey, publicKey } = await generateKeyPair();\n    \n    // 공개키만 PEM 형식으로 변환 (개인키는 extractable: false이므로 변환 불가)\n    const publicKeyPEM = await exportKeyToPEM(publicKey, false);\n    \n    // 개인키는 IndexedDB에 저장 (CryptoKey 객체 자체)\n    await savePrivateKey(privateKey);\n    \n    return {\n      publicKeyPEM,\n    };\n  } catch (error) {\n    console.error('키 생성 및 변환 실패:', error);\n    throw error;\n  }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}