{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\nimport { useAuth } from '../contexts/AuthContext';\nimport { useNotification } from './useNotification';\nimport { useNavigate } from 'react-router-dom';\nimport { tokenManager } from '../utils/api';\n\n/**\n * SSE 알림 스트림 연결 관리 훅\n * 서버에서 실시간 알림을 받아 브라우저 알림으로 표시합니다.\n */\nexport const useNotificationStream = () => {\n  _s();\n  const {\n    user,\n    isAuthenticated\n  } = useAuth();\n  const {\n    showNotification,\n    requestPermission\n  } = useNotification();\n  const navigate = useNavigate();\n  const eventSourceRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000; // 3초\n\n  // SSE 연결 시작\n  const connect = async () => {\n    // 인증되지 않았거나 공개키가 없으면 연결하지 않음\n    // user 객체의 publicKey 또는 public_key 필드 확인\n    const publicKey = (user === null || user === void 0 ? void 0 : user.publicKey) || (user === null || user === void 0 ? void 0 : user.public_key);\n    if (!isAuthenticated || !user || !publicKey || publicKey === '0') {\n      console.log('알림 스트림 연결 불가: 인증되지 않았거나 공개키가 없습니다.');\n      return;\n    }\n\n    // 이미 연결되어 있으면 중복 연결 방지\n    if (eventSourceRef.current && eventSourceRef.current.readyState === EventSource.OPEN) {\n      console.log('이미 알림 스트림에 연결되어 있습니다.');\n      return;\n    }\n    try {\n      // 기존 연결이 있으면 닫기\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n\n      // 알림 권한 요청 (최초 1회)\n      const permissionGranted = await requestPermission();\n      if (!permissionGranted) {\n        console.warn('알림 권한이 허용되지 않았습니다.');\n      }\n\n      // API 기본 URL 가져오기\n      const apiBaseUrl = process.env.REACT_APP_API_URL || 'http://localhost:3001';\n\n      // 토큰 가져오기\n      const token = tokenManager.getAccessToken();\n      if (!token) {\n        console.error('토큰이 없어 알림 스트림에 연결할 수 없습니다.');\n        return;\n      }\n\n      // EventSource는 헤더를 지원하지 않으므로 쿼리 파라미터로 토큰 전달\n      // 또는 서버에서 쿠키를 사용하도록 수정 필요\n      // 일단 쿼리 파라미터로 전달 (보안상 권장하지 않지만 EventSource 제약사항)\n      const eventSource = new EventSource(`${apiBaseUrl}/api/notifications/stream?token=${encodeURIComponent(token)}`);\n      eventSourceRef.current = eventSource;\n      reconnectAttemptsRef.current = 0;\n\n      // 연결 성공\n      eventSource.onopen = () => {\n        console.log('알림 스트림 연결 성공');\n        setIsConnected(true);\n        reconnectAttemptsRef.current = 0;\n      };\n\n      // 메시지 수신\n      eventSource.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          handleNotification(data);\n        } catch (error) {\n          console.error('알림 데이터 파싱 오류:', error);\n        }\n      };\n\n      // 에러 처리\n      eventSource.onerror = error => {\n        console.error('알림 스트림 오류:', error);\n        setIsConnected(false);\n\n        // 연결이 끊어진 경우 재연결 시도\n        if (eventSource.readyState === EventSource.CLOSED) {\n          scheduleReconnect();\n        }\n      };\n    } catch (error) {\n      console.error('알림 스트림 연결 실패:', error);\n      setIsConnected(false);\n      scheduleReconnect();\n    }\n  };\n\n  // 재연결 스케줄링\n  const scheduleReconnect = () => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      console.error('알림 스트림 재연결 시도 횟수 초과');\n      return;\n    }\n    reconnectAttemptsRef.current += 1;\n    const delay = reconnectDelay * reconnectAttemptsRef.current;\n    console.log(`${delay / 1000}초 후 알림 스트림 재연결 시도 (${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\n    reconnectTimeoutRef.current = setTimeout(() => {\n      connect();\n    }, delay);\n  };\n\n  // 알림 처리\n  const handleNotification = data => {\n    console.log('알림 수신:', data);\n\n    // 연결 확인 메시지는 무시\n    if (data.type === 'connected') {\n      return;\n    }\n\n    // 박스 할당 알림 처리\n    if (data.type === 'box_assigned') {\n      var _data$data;\n      showNotification(data.title || '상품 준비 완료', {\n        body: data.message || '상품이 준비되었습니다. 도어락 보안 인증을 위한 얼굴인식을 진행해주세요.',\n        icon: '/images/placeholder.svg',\n        tag: `box-assigned-${(_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.paymentId}`,\n        requireInteraction: true,\n        // 사용자가 클릭할 때까지 유지\n        onClick: () => {\n          // 알림 클릭 시 얼굴인식 페이지로 이동\n          navigate('/face-checkin');\n        },\n        autoClose: 0 // 사용자가 클릭할 때까지 유지\n      });\n    } else {\n      // 기타 알림\n      showNotification(data.title || '알림', {\n        body: data.message || '',\n        icon: '/images/placeholder.svg',\n        tag: data.type,\n        onClick: () => {\n          var _data$action, _data$action2;\n          if (((_data$action = data.action) === null || _data$action === void 0 ? void 0 : _data$action.type) === 'navigate' && (_data$action2 = data.action) !== null && _data$action2 !== void 0 && _data$action2.url) {\n            navigate(data.action.url);\n          }\n        }\n      });\n    }\n  };\n\n  // 연결 종료\n  const disconnect = () => {\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n      eventSourceRef.current = null;\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    setIsConnected(false);\n    reconnectAttemptsRef.current = 0;\n  };\n\n  // 컴포넌트 마운트 시 연결, 언마운트 시 연결 종료\n  useEffect(() => {\n    if (isAuthenticated && user) {\n      connect();\n    }\n    return () => {\n      disconnect();\n    };\n  }, [isAuthenticated, user === null || user === void 0 ? void 0 : user.publicKey, user === null || user === void 0 ? void 0 : user.public_key]); // user.publicKey 또는 user.public_key가 변경되면 재연결\n\n  return {\n    isConnected,\n    connect,\n    disconnect\n  };\n};\n_s(useNotificationStream, \"aigi3WLzZhjyruxiXBeMvJB7b0Y=\", false, function () {\n  return [useAuth, useNotification, useNavigate];\n});","map":{"version":3,"names":["useEffect","useRef","useState","useAuth","useNotification","useNavigate","tokenManager","useNotificationStream","_s","user","isAuthenticated","showNotification","requestPermission","navigate","eventSourceRef","isConnected","setIsConnected","reconnectTimeoutRef","reconnectAttemptsRef","maxReconnectAttempts","reconnectDelay","connect","publicKey","public_key","console","log","current","readyState","EventSource","OPEN","close","permissionGranted","warn","apiBaseUrl","process","env","REACT_APP_API_URL","token","getAccessToken","error","eventSource","encodeURIComponent","onopen","onmessage","event","data","JSON","parse","handleNotification","onerror","CLOSED","scheduleReconnect","delay","setTimeout","type","_data$data","title","body","message","icon","tag","paymentId","requireInteraction","onClick","autoClose","_data$action","_data$action2","action","url","disconnect","clearTimeout"],"sources":["/Users/parkchanyu/Developer/2학기캡스톤/FACT_Front/frontend/src/hooks/useNotificationStream.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { useAuth } from '../contexts/AuthContext';\nimport { useNotification } from './useNotification';\nimport { useNavigate } from 'react-router-dom';\nimport { tokenManager } from '../utils/api';\n\n/**\n * SSE 알림 스트림 연결 관리 훅\n * 서버에서 실시간 알림을 받아 브라우저 알림으로 표시합니다.\n */\nexport const useNotificationStream = () => {\n  const { user, isAuthenticated } = useAuth();\n  const { showNotification, requestPermission } = useNotification();\n  const navigate = useNavigate();\n  const eventSourceRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttemptsRef = useRef(0);\n  const maxReconnectAttempts = 5;\n  const reconnectDelay = 3000; // 3초\n\n  // SSE 연결 시작\n  const connect = async () => {\n    // 인증되지 않았거나 공개키가 없으면 연결하지 않음\n    // user 객체의 publicKey 또는 public_key 필드 확인\n    const publicKey = user?.publicKey || user?.public_key;\n    if (!isAuthenticated || !user || !publicKey || publicKey === '0') {\n      console.log('알림 스트림 연결 불가: 인증되지 않았거나 공개키가 없습니다.');\n      return;\n    }\n\n    // 이미 연결되어 있으면 중복 연결 방지\n    if (eventSourceRef.current && eventSourceRef.current.readyState === EventSource.OPEN) {\n      console.log('이미 알림 스트림에 연결되어 있습니다.');\n      return;\n    }\n\n    try {\n      // 기존 연결이 있으면 닫기\n      if (eventSourceRef.current) {\n        eventSourceRef.current.close();\n      }\n\n      // 알림 권한 요청 (최초 1회)\n      const permissionGranted = await requestPermission();\n      if (!permissionGranted) {\n        console.warn('알림 권한이 허용되지 않았습니다.');\n      }\n\n      // API 기본 URL 가져오기\n      const apiBaseUrl = process.env.REACT_APP_API_URL || 'http://localhost:3001';\n      \n      // 토큰 가져오기\n      const token = tokenManager.getAccessToken();\n\n      if (!token) {\n        console.error('토큰이 없어 알림 스트림에 연결할 수 없습니다.');\n        return;\n      }\n\n      // EventSource는 헤더를 지원하지 않으므로 쿼리 파라미터로 토큰 전달\n      // 또는 서버에서 쿠키를 사용하도록 수정 필요\n      // 일단 쿼리 파라미터로 전달 (보안상 권장하지 않지만 EventSource 제약사항)\n      const eventSource = new EventSource(\n        `${apiBaseUrl}/api/notifications/stream?token=${encodeURIComponent(token)}`\n      );\n\n      eventSourceRef.current = eventSource;\n      reconnectAttemptsRef.current = 0;\n\n      // 연결 성공\n      eventSource.onopen = () => {\n        console.log('알림 스트림 연결 성공');\n        setIsConnected(true);\n        reconnectAttemptsRef.current = 0;\n      };\n\n      // 메시지 수신\n      eventSource.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          handleNotification(data);\n        } catch (error) {\n          console.error('알림 데이터 파싱 오류:', error);\n        }\n      };\n\n      // 에러 처리\n      eventSource.onerror = (error) => {\n        console.error('알림 스트림 오류:', error);\n        setIsConnected(false);\n\n        // 연결이 끊어진 경우 재연결 시도\n        if (eventSource.readyState === EventSource.CLOSED) {\n          scheduleReconnect();\n        }\n      };\n\n    } catch (error) {\n      console.error('알림 스트림 연결 실패:', error);\n      setIsConnected(false);\n      scheduleReconnect();\n    }\n  };\n\n  // 재연결 스케줄링\n  const scheduleReconnect = () => {\n    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {\n      console.error('알림 스트림 재연결 시도 횟수 초과');\n      return;\n    }\n\n    reconnectAttemptsRef.current += 1;\n    const delay = reconnectDelay * reconnectAttemptsRef.current;\n\n    console.log(`${delay / 1000}초 후 알림 스트림 재연결 시도 (${reconnectAttemptsRef.current}/${maxReconnectAttempts})`);\n\n    reconnectTimeoutRef.current = setTimeout(() => {\n      connect();\n    }, delay);\n  };\n\n  // 알림 처리\n  const handleNotification = (data) => {\n    console.log('알림 수신:', data);\n\n    // 연결 확인 메시지는 무시\n    if (data.type === 'connected') {\n      return;\n    }\n\n    // 박스 할당 알림 처리\n    if (data.type === 'box_assigned') {\n      showNotification(data.title || '상품 준비 완료', {\n        body: data.message || '상품이 준비되었습니다. 도어락 보안 인증을 위한 얼굴인식을 진행해주세요.',\n        icon: '/images/placeholder.svg',\n        tag: `box-assigned-${data.data?.paymentId}`,\n        requireInteraction: true, // 사용자가 클릭할 때까지 유지\n        onClick: () => {\n          // 알림 클릭 시 얼굴인식 페이지로 이동\n          navigate('/face-checkin');\n        },\n        autoClose: 0, // 사용자가 클릭할 때까지 유지\n      });\n    } else {\n      // 기타 알림\n      showNotification(data.title || '알림', {\n        body: data.message || '',\n        icon: '/images/placeholder.svg',\n        tag: data.type,\n        onClick: () => {\n          if (data.action?.type === 'navigate' && data.action?.url) {\n            navigate(data.action.url);\n          }\n        },\n      });\n    }\n  };\n\n  // 연결 종료\n  const disconnect = () => {\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n      eventSourceRef.current = null;\n    }\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    setIsConnected(false);\n    reconnectAttemptsRef.current = 0;\n  };\n\n  // 컴포넌트 마운트 시 연결, 언마운트 시 연결 종료\n  useEffect(() => {\n    if (isAuthenticated && user) {\n      connect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [isAuthenticated, user?.publicKey, user?.public_key]); // user.publicKey 또는 user.public_key가 변경되면 재연결\n\n  return {\n    isConnected,\n    connect,\n    disconnect,\n  };\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}