{"ast":null,"code":"// WebCrypto API를 사용한 암호화 유틸리티\n\n// IndexedDB 데이터베이스 이름 및 설정\nconst DB_NAME = 'CryptoKeysDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'privateKeys';\n\n/**\n * IndexedDB 데이터베이스 초기화\n * @returns {Promise<IDBDatabase>}\n */\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = () => {\n      reject(new Error('IndexedDB 초기화 실패'));\n    };\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME, {\n          keyPath: 'id'\n        });\n      }\n    };\n  });\n};\n\n/**\n * RSA 키 쌍 생성 (개인키와 공개키)\n * 개인키는 extractable: true로 생성되어 IndexedDB에 저장 가능\n * @returns {Promise<{privateKey: CryptoKey, publicKey: CryptoKey}>}\n */\nexport const generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: 'RSA-OAEP',\n      modulusLength: 2048,\n      // 2048비트 키\n      publicExponent: new Uint8Array([1, 0, 1]),\n      // 65537\n      hash: 'SHA-256'\n    }, true,\n    // extractable: true - 키를 내보내서 IndexedDB에 저장 가능\n    ['encrypt', 'decrypt'] // 사용 용도\n    );\n    return {\n      privateKey: keyPair.privateKey,\n      publicKey: keyPair.publicKey\n    };\n  } catch (error) {\n    console.error('키 쌍 생성 실패:', error);\n    throw new Error('키 쌍 생성에 실패했습니다.');\n  }\n};\n\n/**\n * CryptoKey를 PEM 형식의 문자열로 변환\n * @param {CryptoKey} key - 변환할 키\n * @param {boolean} isPrivate - 개인키 여부\n * @returns {Promise<string>} PEM 형식의 키 문자열\n */\nexport const exportKeyToPEM = async (key, isPrivate = false) => {\n  try {\n    var _exportedAsBase64$mat;\n    const format = isPrivate ? 'pkcs8' : 'spki';\n    const exported = await window.crypto.subtle.exportKey(format, key);\n    const exportedAsBuffer = new Uint8Array(exported);\n    const exportedAsBase64 = btoa(String.fromCharCode(...exportedAsBuffer));\n    const header = isPrivate ? '-----BEGIN PRIVATE KEY-----\\n' : '-----BEGIN PUBLIC KEY-----\\n';\n    const footer = isPrivate ? '\\n-----END PRIVATE KEY-----' : '\\n-----END PUBLIC KEY-----';\n\n    // 64자마다 줄바꿈 추가\n    const base64WithLineBreaks = ((_exportedAsBase64$mat = exportedAsBase64.match(/.{1,64}/g)) === null || _exportedAsBase64$mat === void 0 ? void 0 : _exportedAsBase64$mat.join('\\n')) || exportedAsBase64;\n    return header + base64WithLineBreaks + footer;\n  } catch (error) {\n    console.error('키 변환 실패:', error);\n    throw new Error('키를 PEM 형식으로 변환하는데 실패했습니다.');\n  }\n};\n\n/**\n * PEM 형식의 키 문자열을 CryptoKey로 복원\n * @param {string} pemKey - PEM 형식의 키 문자열\n * @param {boolean} isPrivate - 개인키 여부\n * @param {string} algorithm - 알고리즘 이름 ('RSA-OAEP' 또는 'RSA-PSS')\n * @param {string[]} keyUsages - 키 사용 용도 (['encrypt', 'decrypt'] 또는 ['sign', 'verify'])\n * @returns {Promise<CryptoKey>} CryptoKey 객체\n */\nexport const importKeyFromPEM = async (pemKey, isPrivate, algorithm = 'RSA-OAEP', keyUsages = ['encrypt', 'decrypt']) => {\n  try {\n    // PEM 헤더와 푸터 제거\n    const base64Key = pemKey.replace(/-----BEGIN (PRIVATE|PUBLIC) KEY-----/g, '').replace(/-----END (PRIVATE|PUBLIC) KEY-----/g, '').replace(/\\s/g, ''); // 모든 공백 제거\n\n    // Base64 디코딩\n    const binaryString = atob(base64Key);\n    const keyBuffer = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      keyBuffer[i] = binaryString.charCodeAt(i);\n    }\n\n    // CryptoKey로 가져오기\n    const format = isPrivate ? 'pkcs8' : 'spki';\n    const key = await window.crypto.subtle.importKey(format, keyBuffer, {\n      name: algorithm,\n      hash: 'SHA-256'\n    }, false,\n    // extractable: false로 복원 (보안 강화)\n    keyUsages);\n    return key;\n  } catch (error) {\n    console.error('키 복원 실패:', error);\n    throw new Error('키를 CryptoKey로 복원하는데 실패했습니다.');\n  }\n};\n\n// 메모리 기반 키 캐시 (성능 최적화용)\nlet privateKeyCache = null;\n\n/**\n * 개인키를 IndexedDB에 안전하게 저장\n * 개인키를 PEM 형식으로 변환하여 IndexedDB에 저장\n * @param {CryptoKey} privateKey - CryptoKey 객체 (extractable: true)\n * @param {string} publicKeyPEM - 공개키 PEM 문자열 (선택적)\n * @returns {Promise<void>}\n */\nexport const savePrivateKey = async (privateKey, publicKeyPEM = null) => {\n  try {\n    // 메모리 캐시에도 저장 (성능 최적화)\n    privateKeyCache = privateKey;\n\n    // 개인키를 PEM 형식으로 변환\n    const privateKeyPEM = await exportKeyToPEM(privateKey, true);\n\n    // IndexedDB에 PEM 형식의 개인키와 공개키 저장\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const keyData = {\n      id: 'userPrivateKey',\n      privateKeyPEM: privateKeyPEM,\n      createdAt: new Date().toISOString()\n    };\n\n    // 공개키가 제공되면 함께 저장\n    if (publicKeyPEM) {\n      keyData.publicKeyPEM = publicKeyPEM;\n    }\n    await new Promise((resolve, reject) => {\n      const request = store.put(keyData);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 저장 실패'));\n    });\n    db.close();\n  } catch (error) {\n    console.error('개인키 저장 실패:', error);\n    throw new Error('개인키 저장에 실패했습니다.');\n  }\n};\n\n/**\n * IndexedDB에서 개인키 가져오기\n * 메모리 캐시가 있으면 우선 사용, 없으면 IndexedDB에서 읽어와서 복원\n * @returns {Promise<CryptoKey|null>} CryptoKey 객체 또는 null\n */\nexport const getPrivateKey = async () => {\n  try {\n    // 메모리 캐시에서 키 가져오기 (성능 최적화)\n    if (privateKeyCache) {\n      return privateKeyCache;\n    }\n\n    // IndexedDB에서 개인키 읽기\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get('userPrivateKey');\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('개인키 읽기 실패'));\n    });\n    db.close();\n\n    // IndexedDB에 개인키가 있는 경우 PEM 형식에서 CryptoKey로 복원\n    if (result !== null && result !== void 0 && result.privateKeyPEM) {\n      try {\n        const privateKey = await importKeyFromPEM(result.privateKeyPEM, true, 'RSA-OAEP', ['encrypt', 'decrypt']);\n        // 메모리 캐시에 저장\n        privateKeyCache = privateKey;\n        return privateKey;\n      } catch (importError) {\n        console.error('개인키 복원 실패:', importError);\n        // 복원 실패 시 IndexedDB에서 해당 키 삭제 (손상된 키일 수 있음)\n        try {\n          const db = await initDB();\n          const transaction = db.transaction([STORE_NAME], 'readwrite');\n          const store = transaction.objectStore(STORE_NAME);\n          await new Promise((resolve, reject) => {\n            const request = store.delete('userPrivateKey');\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(new Error('손상된 개인키 삭제 실패'));\n          });\n          db.close();\n        } catch (deleteError) {\n          console.error('손상된 개인키 삭제 실패:', deleteError);\n        }\n        return null;\n      }\n    }\n    return null;\n  } catch (error) {\n    console.error('개인키 읽기 실패:', error);\n    return null;\n  }\n};\n\n/**\n * 개인키 삭제\n * 메모리와 IndexedDB 모두에서 삭제\n * @returns {Promise<void>}\n */\nexport const clearPrivateKey = async () => {\n  try {\n    // 메모리 캐시 삭제\n    privateKeyCache = null;\n\n    // IndexedDB에서 개인키 삭제\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    await new Promise((resolve, reject) => {\n      const request = store.delete('userPrivateKey');\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 삭제 실패'));\n    });\n    db.close();\n  } catch (error) {\n    console.error('개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 서명용 개인키 삭제\n * 메모리와 IndexedDB 모두에서 삭제\n * @returns {Promise<void>}\n */\nexport const clearSigningPrivateKey = async () => {\n  try {\n    // 메모리 캐시 삭제\n    signingPrivateKeyCache = null;\n\n    // IndexedDB에서 서명용 개인키 삭제\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    await new Promise((resolve, reject) => {\n      const request = store.delete('userSigningPrivateKey');\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('서명용 개인키 삭제 실패'));\n    });\n    db.close();\n  } catch (error) {\n    console.error('서명용 개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 모든 개인키 삭제 (암호화용 + 서명용)\n * 로그아웃 시 사용\n * @returns {Promise<void>}\n */\nexport const clearAllPrivateKeys = async () => {\n  try {\n    await Promise.all([clearPrivateKey(), clearSigningPrivateKey()]);\n  } catch (error) {\n    console.error('모든 개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 키 쌍 생성 및 공개키를 PEM 형식으로 반환\n * 개인키는 extractable: true로 생성되어 IndexedDB에 PEM 형식으로 저장됨\n * @returns {Promise<{publicKeyPEM: string}>}\n */\nexport const generateAndExportKeyPair = async () => {\n  try {\n    // 키 쌍 생성 (개인키는 extractable: true)\n    const {\n      privateKey,\n      publicKey\n    } = await generateKeyPair();\n\n    // 공개키를 PEM 형식으로 변환\n    const publicKeyPEM = await exportKeyToPEM(publicKey, false);\n\n    // 개인키와 공개키를 IndexedDB에 PEM 형식으로 저장\n    await savePrivateKey(privateKey, publicKeyPEM);\n    return {\n      publicKeyPEM\n    };\n  } catch (error) {\n    console.error('키 생성 및 변환 실패:', error);\n    throw error;\n  }\n};\n\n/**\n * 기존 개인키가 있으면 공개키를 반환, 없으면 새로 생성\n * 로그인 시 사용하여 기존 키를 재사용하거나 새 키를 생성\n * @returns {Promise<{publicKeyPEM: string, isNew: boolean}>}\n */\nexport const getOrGenerateKeyPair = async () => {\n  try {\n    // 기존 개인키 확인\n    const existingPrivateKey = await getPrivateKey();\n    if (existingPrivateKey) {\n      // 기존 개인키가 있는 경우, 저장된 공개키를 가져오거나 개인키에서 추출\n      const db = await initDB();\n      const transaction = db.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      const result = await new Promise((resolve, reject) => {\n        const request = store.get('userPrivateKey');\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(new Error('개인키 읽기 실패'));\n      });\n      db.close();\n\n      // 저장된 공개키가 있으면 사용\n      if (result !== null && result !== void 0 && result.publicKeyPEM) {\n        return {\n          publicKeyPEM: result.publicKeyPEM,\n          isNew: false\n        };\n      }\n\n      // 공개키가 없으면 개인키에서 공개키 추출 불가능하므로 새로 생성\n      // (RSA 키 쌍에서는 개인키에서 공개키를 직접 추출할 수 없음)\n      console.warn('저장된 공개키가 없습니다. 새 키 쌍을 생성합니다.');\n      const {\n        publicKeyPEM\n      } = await generateAndExportKeyPair();\n      return {\n        publicKeyPEM,\n        isNew: true\n      };\n    } else {\n      // 개인키가 없으면 새로 생성\n      const {\n        publicKeyPEM\n      } = await generateAndExportKeyPair();\n      return {\n        publicKeyPEM,\n        isNew: true\n      };\n    }\n  } catch (error) {\n    console.error('키 쌍 가져오기 또는 생성 실패:', error);\n    throw error;\n  }\n};\n\n/**\n * 서명용 RSA 키 쌍 생성 (RSA-PSS 알고리즘)\n * 개인키는 extractable: true로 생성되어 IndexedDB에 저장 가능\n * @returns {Promise<{privateKey: CryptoKey, publicKey: CryptoKey}>}\n */\nexport const generateSigningKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey({\n      name: 'RSA-PSS',\n      modulusLength: 2048,\n      // 2048비트 키\n      publicExponent: new Uint8Array([1, 0, 1]),\n      // 65537\n      hash: 'SHA-256'\n    }, true,\n    // extractable: true - 키를 내보내서 IndexedDB에 저장 가능\n    ['sign', 'verify'] // 서명 및 검증 용도\n    );\n    return {\n      privateKey: keyPair.privateKey,\n      publicKey: keyPair.publicKey\n    };\n  } catch (error) {\n    console.error('서명용 키 쌍 생성 실패:', error);\n    throw new Error('서명용 키 쌍 생성에 실패했습니다.');\n  }\n};\n\n// 서명용 개인키 캐시 (성능 최적화용)\nlet signingPrivateKeyCache = null;\n\n/**\n * 서명용 개인키를 IndexedDB에 안전하게 저장\n * 개인키를 PEM 형식으로 변환하여 IndexedDB에 저장\n * @param {CryptoKey} privateKey - 서명용 개인키 CryptoKey 객체 (extractable: true)\n * @returns {Promise<void>}\n */\nexport const saveSigningPrivateKey = async privateKey => {\n  try {\n    // 메모리 캐시에도 저장 (성능 최적화)\n    signingPrivateKeyCache = privateKey;\n\n    // 개인키를 PEM 형식으로 변환\n    const privateKeyPEM = await exportKeyToPEM(privateKey, true);\n\n    // IndexedDB에 PEM 형식의 개인키 저장\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    await new Promise((resolve, reject) => {\n      const request = store.put({\n        id: 'userSigningPrivateKey',\n        privateKeyPEM: privateKeyPEM,\n        createdAt: new Date().toISOString()\n      });\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('서명용 개인키 저장 실패'));\n    });\n    db.close();\n  } catch (error) {\n    console.error('서명용 개인키 저장 실패:', error);\n    throw new Error('서명용 개인키 저장에 실패했습니다.');\n  }\n};\n\n/**\n * IndexedDB에서 서명용 개인키 가져오기\n * 메모리 캐시가 있으면 우선 사용, 없으면 IndexedDB에서 읽어와서 복원\n * @returns {Promise<CryptoKey|null>} 서명용 개인키 CryptoKey 객체 또는 null\n */\nexport const getSigningPrivateKey = async () => {\n  try {\n    // 메모리 캐시에서 키 가져오기 (성능 최적화)\n    if (signingPrivateKeyCache) {\n      return signingPrivateKeyCache;\n    }\n\n    // IndexedDB에서 개인키 읽기\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get('userSigningPrivateKey');\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('서명용 개인키 읽기 실패'));\n    });\n    db.close();\n\n    // IndexedDB에 개인키가 있는 경우 PEM 형식에서 CryptoKey로 복원\n    if (result !== null && result !== void 0 && result.privateKeyPEM) {\n      try {\n        const privateKey = await importKeyFromPEM(result.privateKeyPEM, true, 'RSA-PSS', ['sign', 'verify']);\n        // 메모리 캐시에 저장\n        signingPrivateKeyCache = privateKey;\n        return privateKey;\n      } catch (importError) {\n        console.error('서명용 개인키 복원 실패:', importError);\n        // 복원 실패 시 IndexedDB에서 해당 키 삭제 (손상된 키일 수 있음)\n        try {\n          const db = await initDB();\n          const transaction = db.transaction([STORE_NAME], 'readwrite');\n          const store = transaction.objectStore(STORE_NAME);\n          await new Promise((resolve, reject) => {\n            const request = store.delete('userSigningPrivateKey');\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(new Error('손상된 서명용 개인키 삭제 실패'));\n          });\n          db.close();\n        } catch (deleteError) {\n          console.error('손상된 서명용 개인키 삭제 실패:', deleteError);\n        }\n        return null;\n      }\n    }\n    return null;\n  } catch (error) {\n    console.error('서명용 개인키 읽기 실패:', error);\n    return null;\n  }\n};\n\n/**\n * 데이터를 개인키로 서명\n * @param {Object} data - 서명할 데이터 객체\n * @returns {Promise<string>} Base64로 인코딩된 서명 문자열\n */\nexport const signData = async data => {\n  try {\n    // 서명용 개인키 가져오기\n    let privateKey = await getSigningPrivateKey();\n\n    // 키가 없으면 생성\n    if (!privateKey) {\n      const {\n        privateKey: newPrivateKey\n      } = await generateSigningKeyPair();\n      await saveSigningPrivateKey(newPrivateKey);\n      privateKey = newPrivateKey;\n    }\n\n    // 데이터를 JSON 문자열로 변환\n    const dataString = JSON.stringify(data);\n\n    // 문자열을 Uint8Array로 변환\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(dataString);\n\n    // 서명 생성\n    const signature = await window.crypto.subtle.sign({\n      name: 'RSA-PSS',\n      saltLength: 32 // 솔트 길이\n    }, privateKey, dataBuffer);\n\n    // 서명을 Base64 문자열로 변환\n    const signatureArray = new Uint8Array(signature);\n    const signatureBase64 = btoa(String.fromCharCode(...signatureArray));\n    return signatureBase64;\n  } catch (error) {\n    console.error('데이터 서명 실패:', error);\n    throw new Error('데이터 서명에 실패했습니다.');\n  }\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","STORE_NAME","initDB","Promise","resolve","reject","request","indexedDB","open","onerror","Error","onsuccess","result","onupgradeneeded","event","db","target","objectStoreNames","contains","createObjectStore","keyPath","generateKeyPair","keyPair","window","crypto","subtle","generateKey","name","modulusLength","publicExponent","Uint8Array","hash","privateKey","publicKey","error","console","exportKeyToPEM","key","isPrivate","_exportedAsBase64$mat","format","exported","exportKey","exportedAsBuffer","exportedAsBase64","btoa","String","fromCharCode","header","footer","base64WithLineBreaks","match","join","importKeyFromPEM","pemKey","algorithm","keyUsages","base64Key","replace","binaryString","atob","keyBuffer","length","i","charCodeAt","importKey","privateKeyCache","savePrivateKey","publicKeyPEM","privateKeyPEM","transaction","store","objectStore","keyData","id","createdAt","Date","toISOString","put","close","getPrivateKey","get","importError","delete","deleteError","clearPrivateKey","clearSigningPrivateKey","signingPrivateKeyCache","clearAllPrivateKeys","all","generateAndExportKeyPair","getOrGenerateKeyPair","existingPrivateKey","isNew","warn","generateSigningKeyPair","saveSigningPrivateKey","getSigningPrivateKey","signData","data","newPrivateKey","dataString","JSON","stringify","encoder","TextEncoder","dataBuffer","encode","signature","sign","saltLength","signatureArray","signatureBase64"],"sources":["/Users/parkchanyu/Developer/FACT_Front/frontend/src/utils/crypto.js"],"sourcesContent":["// WebCrypto API를 사용한 암호화 유틸리티\n\n// IndexedDB 데이터베이스 이름 및 설정\nconst DB_NAME = 'CryptoKeysDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'privateKeys';\n\n/**\n * IndexedDB 데이터베이스 초기화\n * @returns {Promise<IDBDatabase>}\n */\nconst initDB = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n    request.onerror = () => {\n      reject(new Error('IndexedDB 초기화 실패'));\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n      }\n    };\n  });\n};\n\n/**\n * RSA 키 쌍 생성 (개인키와 공개키)\n * 개인키는 extractable: true로 생성되어 IndexedDB에 저장 가능\n * @returns {Promise<{privateKey: CryptoKey, publicKey: CryptoKey}>}\n */\nexport const generateKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey(\n      {\n        name: 'RSA-OAEP',\n        modulusLength: 2048, // 2048비트 키\n        publicExponent: new Uint8Array([1, 0, 1]), // 65537\n        hash: 'SHA-256',\n      },\n      true, // extractable: true - 키를 내보내서 IndexedDB에 저장 가능\n      ['encrypt', 'decrypt'] // 사용 용도\n    );\n\n    return {\n      privateKey: keyPair.privateKey,\n      publicKey: keyPair.publicKey,\n    };\n  } catch (error) {\n    console.error('키 쌍 생성 실패:', error);\n    throw new Error('키 쌍 생성에 실패했습니다.');\n  }\n};\n\n/**\n * CryptoKey를 PEM 형식의 문자열로 변환\n * @param {CryptoKey} key - 변환할 키\n * @param {boolean} isPrivate - 개인키 여부\n * @returns {Promise<string>} PEM 형식의 키 문자열\n */\nexport const exportKeyToPEM = async (key, isPrivate = false) => {\n  try {\n    const format = isPrivate ? 'pkcs8' : 'spki';\n    const exported = await window.crypto.subtle.exportKey(format, key);\n    const exportedAsBuffer = new Uint8Array(exported);\n    const exportedAsBase64 = btoa(String.fromCharCode(...exportedAsBuffer));\n    const header = isPrivate\n      ? '-----BEGIN PRIVATE KEY-----\\n'\n      : '-----BEGIN PUBLIC KEY-----\\n';\n    const footer = isPrivate\n      ? '\\n-----END PRIVATE KEY-----'\n      : '\\n-----END PUBLIC KEY-----';\n    \n    // 64자마다 줄바꿈 추가\n    const base64WithLineBreaks = exportedAsBase64.match(/.{1,64}/g)?.join('\\n') || exportedAsBase64;\n    \n    return header + base64WithLineBreaks + footer;\n  } catch (error) {\n    console.error('키 변환 실패:', error);\n    throw new Error('키를 PEM 형식으로 변환하는데 실패했습니다.');\n  }\n};\n\n/**\n * PEM 형식의 키 문자열을 CryptoKey로 복원\n * @param {string} pemKey - PEM 형식의 키 문자열\n * @param {boolean} isPrivate - 개인키 여부\n * @param {string} algorithm - 알고리즘 이름 ('RSA-OAEP' 또는 'RSA-PSS')\n * @param {string[]} keyUsages - 키 사용 용도 (['encrypt', 'decrypt'] 또는 ['sign', 'verify'])\n * @returns {Promise<CryptoKey>} CryptoKey 객체\n */\nexport const importKeyFromPEM = async (pemKey, isPrivate, algorithm = 'RSA-OAEP', keyUsages = ['encrypt', 'decrypt']) => {\n  try {\n    // PEM 헤더와 푸터 제거\n    const base64Key = pemKey\n      .replace(/-----BEGIN (PRIVATE|PUBLIC) KEY-----/g, '')\n      .replace(/-----END (PRIVATE|PUBLIC) KEY-----/g, '')\n      .replace(/\\s/g, ''); // 모든 공백 제거\n\n    // Base64 디코딩\n    const binaryString = atob(base64Key);\n    const keyBuffer = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      keyBuffer[i] = binaryString.charCodeAt(i);\n    }\n\n    // CryptoKey로 가져오기\n    const format = isPrivate ? 'pkcs8' : 'spki';\n    const key = await window.crypto.subtle.importKey(\n      format,\n      keyBuffer,\n      {\n        name: algorithm,\n        hash: 'SHA-256',\n      },\n      false, // extractable: false로 복원 (보안 강화)\n      keyUsages\n    );\n\n    return key;\n  } catch (error) {\n    console.error('키 복원 실패:', error);\n    throw new Error('키를 CryptoKey로 복원하는데 실패했습니다.');\n  }\n};\n\n// 메모리 기반 키 캐시 (성능 최적화용)\nlet privateKeyCache = null;\n\n/**\n * 개인키를 IndexedDB에 안전하게 저장\n * 개인키를 PEM 형식으로 변환하여 IndexedDB에 저장\n * @param {CryptoKey} privateKey - CryptoKey 객체 (extractable: true)\n * @param {string} publicKeyPEM - 공개키 PEM 문자열 (선택적)\n * @returns {Promise<void>}\n */\nexport const savePrivateKey = async (privateKey, publicKeyPEM = null) => {\n  try {\n    // 메모리 캐시에도 저장 (성능 최적화)\n    privateKeyCache = privateKey;\n    \n    // 개인키를 PEM 형식으로 변환\n    const privateKeyPEM = await exportKeyToPEM(privateKey, true);\n    \n    // IndexedDB에 PEM 형식의 개인키와 공개키 저장\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    const keyData = {\n      id: 'userPrivateKey',\n      privateKeyPEM: privateKeyPEM,\n      createdAt: new Date().toISOString(),\n    };\n    \n    // 공개키가 제공되면 함께 저장\n    if (publicKeyPEM) {\n      keyData.publicKeyPEM = publicKeyPEM;\n    }\n\n    await new Promise((resolve, reject) => {\n      const request = store.put(keyData);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 저장 실패'));\n    });\n\n    db.close();\n  } catch (error) {\n    console.error('개인키 저장 실패:', error);\n    throw new Error('개인키 저장에 실패했습니다.');\n  }\n};\n\n/**\n * IndexedDB에서 개인키 가져오기\n * 메모리 캐시가 있으면 우선 사용, 없으면 IndexedDB에서 읽어와서 복원\n * @returns {Promise<CryptoKey|null>} CryptoKey 객체 또는 null\n */\nexport const getPrivateKey = async () => {\n  try {\n    // 메모리 캐시에서 키 가져오기 (성능 최적화)\n    if (privateKeyCache) {\n      return privateKeyCache;\n    }\n\n    // IndexedDB에서 개인키 읽기\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get('userPrivateKey');\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('개인키 읽기 실패'));\n    });\n\n    db.close();\n\n    // IndexedDB에 개인키가 있는 경우 PEM 형식에서 CryptoKey로 복원\n    if (result?.privateKeyPEM) {\n      try {\n        const privateKey = await importKeyFromPEM(\n          result.privateKeyPEM,\n          true,\n          'RSA-OAEP',\n          ['encrypt', 'decrypt']\n        );\n        // 메모리 캐시에 저장\n        privateKeyCache = privateKey;\n        return privateKey;\n      } catch (importError) {\n        console.error('개인키 복원 실패:', importError);\n        // 복원 실패 시 IndexedDB에서 해당 키 삭제 (손상된 키일 수 있음)\n        try {\n          const db = await initDB();\n          const transaction = db.transaction([STORE_NAME], 'readwrite');\n          const store = transaction.objectStore(STORE_NAME);\n          await new Promise((resolve, reject) => {\n            const request = store.delete('userPrivateKey');\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(new Error('손상된 개인키 삭제 실패'));\n          });\n          db.close();\n        } catch (deleteError) {\n          console.error('손상된 개인키 삭제 실패:', deleteError);\n        }\n        return null;\n      }\n    }\n\n    return null;\n  } catch (error) {\n    console.error('개인키 읽기 실패:', error);\n    return null;\n  }\n};\n\n/**\n * 개인키 삭제\n * 메모리와 IndexedDB 모두에서 삭제\n * @returns {Promise<void>}\n */\nexport const clearPrivateKey = async () => {\n  try {\n    // 메모리 캐시 삭제\n    privateKeyCache = null;\n\n    // IndexedDB에서 개인키 삭제\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise((resolve, reject) => {\n      const request = store.delete('userPrivateKey');\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('개인키 삭제 실패'));\n    });\n\n    db.close();\n  } catch (error) {\n    console.error('개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 서명용 개인키 삭제\n * 메모리와 IndexedDB 모두에서 삭제\n * @returns {Promise<void>}\n */\nexport const clearSigningPrivateKey = async () => {\n  try {\n    // 메모리 캐시 삭제\n    signingPrivateKeyCache = null;\n\n    // IndexedDB에서 서명용 개인키 삭제\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise((resolve, reject) => {\n      const request = store.delete('userSigningPrivateKey');\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('서명용 개인키 삭제 실패'));\n    });\n\n    db.close();\n  } catch (error) {\n    console.error('서명용 개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 모든 개인키 삭제 (암호화용 + 서명용)\n * 로그아웃 시 사용\n * @returns {Promise<void>}\n */\nexport const clearAllPrivateKeys = async () => {\n  try {\n    await Promise.all([\n      clearPrivateKey(),\n      clearSigningPrivateKey(),\n    ]);\n  } catch (error) {\n    console.error('모든 개인키 삭제 실패:', error);\n  }\n};\n\n/**\n * 키 쌍 생성 및 공개키를 PEM 형식으로 반환\n * 개인키는 extractable: true로 생성되어 IndexedDB에 PEM 형식으로 저장됨\n * @returns {Promise<{publicKeyPEM: string}>}\n */\nexport const generateAndExportKeyPair = async () => {\n  try {\n    // 키 쌍 생성 (개인키는 extractable: true)\n    const { privateKey, publicKey } = await generateKeyPair();\n    \n    // 공개키를 PEM 형식으로 변환\n    const publicKeyPEM = await exportKeyToPEM(publicKey, false);\n    \n    // 개인키와 공개키를 IndexedDB에 PEM 형식으로 저장\n    await savePrivateKey(privateKey, publicKeyPEM);\n    \n    return {\n      publicKeyPEM,\n    };\n  } catch (error) {\n    console.error('키 생성 및 변환 실패:', error);\n    throw error;\n  }\n};\n\n/**\n * 기존 개인키가 있으면 공개키를 반환, 없으면 새로 생성\n * 로그인 시 사용하여 기존 키를 재사용하거나 새 키를 생성\n * @returns {Promise<{publicKeyPEM: string, isNew: boolean}>}\n */\nexport const getOrGenerateKeyPair = async () => {\n  try {\n    // 기존 개인키 확인\n    const existingPrivateKey = await getPrivateKey();\n    \n    if (existingPrivateKey) {\n      // 기존 개인키가 있는 경우, 저장된 공개키를 가져오거나 개인키에서 추출\n      const db = await initDB();\n      const transaction = db.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      const result = await new Promise((resolve, reject) => {\n        const request = store.get('userPrivateKey');\n        request.onsuccess = () => resolve(request.result);\n        request.onerror = () => reject(new Error('개인키 읽기 실패'));\n      });\n      \n      db.close();\n      \n      // 저장된 공개키가 있으면 사용\n      if (result?.publicKeyPEM) {\n        return {\n          publicKeyPEM: result.publicKeyPEM,\n          isNew: false,\n        };\n      }\n      \n      // 공개키가 없으면 개인키에서 공개키 추출 불가능하므로 새로 생성\n      // (RSA 키 쌍에서는 개인키에서 공개키를 직접 추출할 수 없음)\n      console.warn('저장된 공개키가 없습니다. 새 키 쌍을 생성합니다.');\n      const { publicKeyPEM } = await generateAndExportKeyPair();\n      return {\n        publicKeyPEM,\n        isNew: true,\n      };\n    } else {\n      // 개인키가 없으면 새로 생성\n      const { publicKeyPEM } = await generateAndExportKeyPair();\n      return {\n        publicKeyPEM,\n        isNew: true,\n      };\n    }\n  } catch (error) {\n    console.error('키 쌍 가져오기 또는 생성 실패:', error);\n    throw error;\n  }\n};\n\n/**\n * 서명용 RSA 키 쌍 생성 (RSA-PSS 알고리즘)\n * 개인키는 extractable: true로 생성되어 IndexedDB에 저장 가능\n * @returns {Promise<{privateKey: CryptoKey, publicKey: CryptoKey}>}\n */\nexport const generateSigningKeyPair = async () => {\n  try {\n    const keyPair = await window.crypto.subtle.generateKey(\n      {\n        name: 'RSA-PSS',\n        modulusLength: 2048, // 2048비트 키\n        publicExponent: new Uint8Array([1, 0, 1]), // 65537\n        hash: 'SHA-256',\n      },\n      true, // extractable: true - 키를 내보내서 IndexedDB에 저장 가능\n      ['sign', 'verify'] // 서명 및 검증 용도\n    );\n\n    return {\n      privateKey: keyPair.privateKey,\n      publicKey: keyPair.publicKey,\n    };\n  } catch (error) {\n    console.error('서명용 키 쌍 생성 실패:', error);\n    throw new Error('서명용 키 쌍 생성에 실패했습니다.');\n  }\n};\n\n// 서명용 개인키 캐시 (성능 최적화용)\nlet signingPrivateKeyCache = null;\n\n/**\n * 서명용 개인키를 IndexedDB에 안전하게 저장\n * 개인키를 PEM 형식으로 변환하여 IndexedDB에 저장\n * @param {CryptoKey} privateKey - 서명용 개인키 CryptoKey 객체 (extractable: true)\n * @returns {Promise<void>}\n */\nexport const saveSigningPrivateKey = async (privateKey) => {\n  try {\n    // 메모리 캐시에도 저장 (성능 최적화)\n    signingPrivateKeyCache = privateKey;\n    \n    // 개인키를 PEM 형식으로 변환\n    const privateKeyPEM = await exportKeyToPEM(privateKey, true);\n    \n    // IndexedDB에 PEM 형식의 개인키 저장\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n\n    await new Promise((resolve, reject) => {\n      const request = store.put({\n        id: 'userSigningPrivateKey',\n        privateKeyPEM: privateKeyPEM,\n        createdAt: new Date().toISOString(),\n      });\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(new Error('서명용 개인키 저장 실패'));\n    });\n\n    db.close();\n  } catch (error) {\n    console.error('서명용 개인키 저장 실패:', error);\n    throw new Error('서명용 개인키 저장에 실패했습니다.');\n  }\n};\n\n/**\n * IndexedDB에서 서명용 개인키 가져오기\n * 메모리 캐시가 있으면 우선 사용, 없으면 IndexedDB에서 읽어와서 복원\n * @returns {Promise<CryptoKey|null>} 서명용 개인키 CryptoKey 객체 또는 null\n */\nexport const getSigningPrivateKey = async () => {\n  try {\n    // 메모리 캐시에서 키 가져오기 (성능 최적화)\n    if (signingPrivateKeyCache) {\n      return signingPrivateKeyCache;\n    }\n\n    // IndexedDB에서 개인키 읽기\n    const db = await initDB();\n    const transaction = db.transaction([STORE_NAME], 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n\n    const result = await new Promise((resolve, reject) => {\n      const request = store.get('userSigningPrivateKey');\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(new Error('서명용 개인키 읽기 실패'));\n    });\n\n    db.close();\n\n    // IndexedDB에 개인키가 있는 경우 PEM 형식에서 CryptoKey로 복원\n    if (result?.privateKeyPEM) {\n      try {\n        const privateKey = await importKeyFromPEM(\n          result.privateKeyPEM,\n          true,\n          'RSA-PSS',\n          ['sign', 'verify']\n        );\n        // 메모리 캐시에 저장\n        signingPrivateKeyCache = privateKey;\n        return privateKey;\n      } catch (importError) {\n        console.error('서명용 개인키 복원 실패:', importError);\n        // 복원 실패 시 IndexedDB에서 해당 키 삭제 (손상된 키일 수 있음)\n        try {\n          const db = await initDB();\n          const transaction = db.transaction([STORE_NAME], 'readwrite');\n          const store = transaction.objectStore(STORE_NAME);\n          await new Promise((resolve, reject) => {\n            const request = store.delete('userSigningPrivateKey');\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(new Error('손상된 서명용 개인키 삭제 실패'));\n          });\n          db.close();\n        } catch (deleteError) {\n          console.error('손상된 서명용 개인키 삭제 실패:', deleteError);\n        }\n        return null;\n      }\n    }\n\n    return null;\n  } catch (error) {\n    console.error('서명용 개인키 읽기 실패:', error);\n    return null;\n  }\n};\n\n/**\n * 데이터를 개인키로 서명\n * @param {Object} data - 서명할 데이터 객체\n * @returns {Promise<string>} Base64로 인코딩된 서명 문자열\n */\nexport const signData = async (data) => {\n  try {\n    // 서명용 개인키 가져오기\n    let privateKey = await getSigningPrivateKey();\n    \n    // 키가 없으면 생성\n    if (!privateKey) {\n      const { privateKey: newPrivateKey } = await generateSigningKeyPair();\n      await saveSigningPrivateKey(newPrivateKey);\n      privateKey = newPrivateKey;\n    }\n\n    // 데이터를 JSON 문자열로 변환\n    const dataString = JSON.stringify(data);\n    \n    // 문자열을 Uint8Array로 변환\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(dataString);\n\n    // 서명 생성\n    const signature = await window.crypto.subtle.sign(\n      {\n        name: 'RSA-PSS',\n        saltLength: 32, // 솔트 길이\n      },\n      privateKey,\n      dataBuffer\n    );\n\n    // 서명을 Base64 문자열로 변환\n    const signatureArray = new Uint8Array(signature);\n    const signatureBase64 = btoa(String.fromCharCode(...signatureArray));\n\n    return signatureBase64;\n  } catch (error) {\n    console.error('데이터 서명 실패:', error);\n    throw new Error('데이터 서명에 실패했습니다.');\n  }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}